# 2 认识O(NlogN)的排序

## 题目一 归并排序

1) 整体就是一个简单递归，左边排好序、右边排好序、让其整体有序
2) 让其整体有序的过程里用了外排序方法（外排序：两个指针比较的东西拷贝到一个外部的数组里去，然后再拷贝回来）
3) 利用master公式来求解时间复杂度
4) 归并排序的实质

- 时间复杂度O(N*logN)，额外空间复杂度O(N)

## 题目二 归并排序的扩展

- 小和问题和逆序对问题
    - 小和问题
        - 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
            - 例子:[1,3,4,2,5]1左边比1小的数，没有;3左边比3小的数，1;4左边比4小的数，1、3; 2左边比2小的数，1;5左边比5小的数，1、3、4、2;所以小和为1+1+3+1+1+3+4+2=16
    - 逆序对问题
        - 在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，求所有逆序对。

## 题目三 堆

1) 堆结构就是用数组实现的完全二叉树结构
    - 本就是满的或从左往右依次变满的树叫完全二叉树
    - 将数组从0出发的连续一段可以对应成完全二叉树
    - i位置的左孩子：2*i+1 右孩子：2*i+2 父：（i-1）/2
2) 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3) 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4) 堆结构的heapInsert与heapify操作
5) 堆结构的增大和减少
6) 优先级队列结构，就是堆结构，不是队列，堆顶优先级最大

## 题目四 堆排序

- 先让整个数组都变成大根堆结构，建立堆的过程:
    - 从上到下的方法，时间复杂度为O(N*logN)
    - 从下到上的方法，时间复杂度为O(N)
- 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)
- 堆的大小减小成0之后，排序完成

## 题目五 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

```java
import java.util.PriorityQueue;
//默认小根堆
PriorityQueue<Object> heap=new PriorityQueue<>();
```

扩容问题：

- 当底层数组耗尽时，成倍扩容
- 单次扩容代价为O(N)，扩容次数是O(logN)，平均到每次扩容的代价为O(N*logN) / N = O(logN)

## 题目六 荷兰国旗问题

- 问题一
    - 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
    - (1)[i]<=num,[i]和<=区的下一个数做交换，<=区域右扩，i++
    - (2)[i]>num,i++
- 问题二(荷兰国旗问题)
    - 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度 O(N)
    - (1)[i]<num，[i]和<区下一个交换，<区右扩，i++
    - (2)[i]=num，i++
    - (3)[i]>num，[i]和>区前一个交换，>区左扩，i原地不变

## 题目七 不改进的快速排序

1) 把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部 分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行

- 分析

1) 划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低
2) 可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

## 题目八 随机快速排序（改进的快速排序）

1) 在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 成三个部分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行
3) 时间复杂度为O(N*logN)
