# algorithm

## 1 认识复杂度和简单排序算法

### 题目一 认识时间复杂度 常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少次常数操作，进而总结出常数操作的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

### 题目二 选择排序、冒泡排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1)（只需要有限几个变量就可以完成算法流程）

### 题目三 插入排序细节的讲解与复杂度分析

- 时间复杂度O(N^2)，额外空间复杂度O(1)
- 算法流程按照最差情况来估计时间复杂度(数据状况不同时间复杂度也不同)

### 题目四 二分法的详解及扩展

1) 在一个有序数组中，找某个数是否存在
2) 在一个有序数组中，找>=某个数最左侧的位置
3) 局部最小值问题:
    - a数组中，无序，相邻数不一定相等，0位置上的数小于1位置上的数，N位置上的数小于N-1位置上的数，或者i-1<i<i+1（求低谷区）

### 题目五 异或运算的性质及拓展

相同为0，不同为1，也可理解为无进位相加。

1) 0^N=N N^N=0
2) 满足交换律和结合律 a^b=b^a a^b^c=a^(b^c) 注：a和b在内存里是两块独立的区域
3) 一堆数进行亦或与异或顺序无关
4) 不用额外变量交换两个数

- 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
- 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数
    - 要求：时间复杂度为O(N) 额外空间复杂度为O(1)

### 题目六 对数器的概念和使用

1) 有一个你想要测的方法a
2) 实现复杂度不好但是容易实现的方法b
3) 实现一个随机样本产生器
4) 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5) 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者 方法b
6) 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

### 题目七 剖析递归行为和递归行为时间复杂度的估算

- 用递归方法找一个数组中的最大值，系统上到底是怎么做的？
- master公式的使用
    - T(N) = a*T(N/b) + O(N^d)
    - T(N):母问题数据规模
    - T(N/b):子问题数据规模(子问题规模必须相同的递归才能使用master公式)
    - a:子问题被调用次数
    - O(N^d):剩余其他的时间复杂度

1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)

## 2 认识O(NlogN)的排序

### 题目一 归并排序

1) 整体就是一个简单递归，左边排好序、右边排好序、让其整体有序
2) 让其整体有序的过程里用了外排序方法（外排序：两个指针比较的东西拷贝到一个外部的数组里去，然后再拷贝回来）
3) 利用master公式来求解时间复杂度
4) 归并排序的实质

- 时间复杂度O(N*logN)，额外空间复杂度O(N)

### 题目二 归并排序的扩展

- 小和问题和逆序对问题
    - 小和问题
        - 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
            - 例子:[1,3,4,2,5]1左边比1小的数，没有;3左边比3小的数，1;4左边比4小的数，1、3; 2左边比2小的数，1;5左边比5小的数，1、3、4、2;所以小和为1+1+3+1+1+3+4+2=16
    - 逆序对问题
        - 在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，求所有逆序对。

### 题目三 堆

1) 堆结构就是用数组实现的完全二叉树结构
    - 本就是满的或从左往右依次变满的树叫完全二叉树
    - 将数组从0出发的连续一段可以对应成完全二叉树
    - i位置的左孩子：2*i+1 右孩子：2*i+2 父：（i-1）/2
2) 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3) 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4) 堆结构的heapInsert与heapify操作
5) 堆结构的增大和减少
6) 优先级队列结构，就是堆结构，不是队列，堆顶优先级最大

### 题目四 堆排序

- 先让整个数组都变成大根堆结构，建立堆的过程:
    - 从上到下的方法，时间复杂度为O(N*logN)
    - 从下到上的方法，时间复杂度为O(N)
- 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)
- 堆的大小减小成0之后，排序完成

### 题目五 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

```java
import java.util.PriorityQueue;
//默认小根堆
PriorityQueue<Object> heap=new PriorityQueue<>();
```

扩容问题：

- 当底层数组耗尽时，成倍扩容
- 单次扩容代价为O(N)，扩容次数是O(logN)，平均到每次扩容的代价为O(N*logN) / N = O(logN)

### 题目六 荷兰国旗问题

- 问题一
    - 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
    - (1)[i]<=num,[i]和<=区的下一个数做交换，<=区域右扩，i++
    - (2)[i]>num,i++
- 问题二(荷兰国旗问题)
    - 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度 O(N)
    - (1)[i]<num，[i]和<区下一个交换，<区右扩，i++
    - (2)[i]=num，i++
    - (3)[i]>num，[i]和>区前一个交换，>区左扩，i原地不变

### 题目七 不改进的快速排序

1) 把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部 分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行

- 分析

1) 划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低
2) 可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

### 题目八 随机快速排序（改进的快速排序）

1) 在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 成三个部分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行
3) 时间复杂度为O(N*logN)

## 3 详解桶排序

### 题目一 比较器的使用

1) 比较器的实质就是重载比较运算符
2) 比较器可以很好的应用在特殊标准的排序上
3) 比较器可以很好的应用在根据特殊标准排序的结构上

### 题目二 桶排序思想下的排序

1) 计数排序
2) 基数排序

分析:

- 桶排序思想下的排序都是不基于比较的排序
- 时间复杂度为O(N)，额外空间负载度O(M)
- 应用范围有限，需要样本的数据状况满足桶的划分

### 题目三 排序算法的稳定性及其汇总

同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。

不具备稳定性的排序: 选择排序、快速排序、堆排序

具备稳定性的排序: 冒泡排序、插入排序、归并排序、一切桶排序思想下的排序

目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。

### 题目四 常见的坑

1) 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴 趣可以搜“归并排序 内部缓存法”
2) “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2)
3) 快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜“01 stable sort”
4) 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复 杂度O(1)，又稳定的排序。
5) 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对 次序不变，碰到这个问题，可以怼面试官。

### 题目五 工程上对排序的改进

1) 充分利用O(N*logN)和O(N^2)排序各自的优势
2) 稳定性的考虑
