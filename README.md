# algorithm

## 1 认识复杂度和简单排序算法

### 题目一 认识时间复杂度 常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少次常数操作，进而总结出常数操作的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

### 题目二 选择排序、冒泡排序细节的讲解与复杂度分析

时间复杂度O(N^2)，额外空间复杂度O(1)（只需要有限几个变量就可以完成算法流程）

### 题目三 插入排序细节的讲解与复杂度分析

- 时间复杂度O(N^2)，额外空间复杂度O(1)
- 算法流程按照最差情况来估计时间复杂度(数据状况不同时间复杂度也不同)

### 题目四 二分法的详解及扩展

1) 在一个有序数组中，找某个数是否存在
2) 在一个有序数组中，找>=某个数最左侧的位置
3) 局部最小值问题:
    - a数组中，无序，相邻数不一定相等，0位置上的数小于1位置上的数，N位置上的数小于N-1位置上的数，或者i-1<i<i+1（求低谷区）

### 题目五 异或运算的性质及拓展

相同为0，不同为1，也可理解为无进位相加。

1) 0^N=N N^N=0
2) 满足交换律和结合律 a^b=b^a a^b^c=a^(b^c) 注：a和b在内存里是两块独立的区域
3) 一堆数进行亦或与异或顺序无关
4) 不用额外变量交换两个数

- 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
- 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数
    - 要求：时间复杂度为O(N) 额外空间复杂度为O(1)

### 题目六 对数器的概念和使用

1) 有一个你想要测的方法a
2) 实现复杂度不好但是容易实现的方法b
3) 实现一个随机样本产生器
4) 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5) 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者 方法b
6) 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

### 题目七 剖析递归行为和递归行为时间复杂度的估算

- 用递归方法找一个数组中的最大值，系统上到底是怎么做的？
- master公式的使用
    - T(N) = a*T(N/b) + O(N^d)
    - T(N):母问题数据规模
    - T(N/b):子问题数据规模(子问题规模必须相同的递归才能使用master公式)
    - a:子问题被调用次数
    - O(N^d):剩余其他的时间复杂度

1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)

## 2 认识O(NlogN)的排序

### 题目一 归并排序

1) 整体就是一个简单递归，左边排好序、右边排好序、让其整体有序
2) 让其整体有序的过程里用了外排序方法（外排序：两个指针比较的东西拷贝到一个外部的数组里去，然后再拷贝回来）
3) 利用master公式来求解时间复杂度
4) 归并排序的实质

- 时间复杂度O(N*logN)，额外空间复杂度O(N)

### 题目二 归并排序的扩展

- 小和问题和逆序对问题
- 小和问题
- 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组 的小和。求一个数组 的小和。
- 例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 2; 所以小和为1+1+3+1+1+3+4+2=16
- 逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数 构成一个逆序对，请打印所有逆序 对。

### 题目三 堆

1) 堆结构就是用数组实现的完全二叉树结构
2) 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3) 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4) 堆结构的heapInsert与heapify操作
5) 堆结构的增大和减少
6) 优先级队列结构，就是堆结构

### 题目四 堆排序

- 先让整个数组都变成大根堆结构，建立堆的过程:
    - 从上到下的方法，时间复杂度为O(N*logN)
    - 从下到上的方法，时间复杂度为O(N)
- 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调 整堆，一直周而复始，时间复杂度为O(N*logN)
- 堆的大小减小成0之后，排序完成

### 题目五 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序。

### 题目六 荷兰国旗问题

- 问题一
    - 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
- 问题二(荷兰国旗问题)
    - 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)

### 题目七 不改进的快速排序

1) 把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部 分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行

- 分析

1) 划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低
2) 可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

### 题目八 随机快速排序（改进的快速排序）

1) 在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 成三个部分： 左侧<划分值、中间==划分值、右侧>划分值
2) 对左侧范围和右侧范围，递归执行
3) 时间复杂度为O(N*logN)
